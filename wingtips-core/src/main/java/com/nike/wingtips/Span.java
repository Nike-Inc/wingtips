package com.nike.wingtips;

import com.nike.wingtips.util.TracerManagedSpanStatus;

import java.util.Collections;
import java.util.HashMap;
import java.util.Map;
import java.util.Objects;
import java.util.concurrent.TimeUnit;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * Represents some logical "unit of work" that is part of the larger distributed trace. A given request's trace tree is made up of all the spans with the same {@link #traceId}
 * and the spans are connected via parent-child relationship. The first span in the trace tree covers the entire distributed trace - it is often referred to as the root span.
 *
 * <p>For any given service call in a distributed trace there is usually one span covering the full call; that service-level span is started when a request first hits the service
 * and {@link #complete()} is called when the response is sent to the caller, and at that point the resulting completed span is logged or otherwise sent to a span collector
 * of some sort so the span's data can be used later for investigations/aggregations/statistics.
 *
 * <p>Extra "sub-spans" can be generated by a service if it wants additional tracing around specific functions inside the service. One sub-span example might be to create a sub-span
 * in service A when it makes a downstream call to service B. You could then subtract {@link #getDurationNanos()} for service B's service-level span from the time spent in
 * service A's downstream call span to determine what the network lag was for that call.
 *
 * <p>Spans support Java try-with-resources statements to help guarantee proper usage in blocking/non-async scenarios
 * (for asynchronous scenarios please refer to <a href="https://github.com/Nike-Inc/wingtips#async_usage">the
 * asynchronous usage section of the Wingtips readme</a>). Here are some examples.
 *
 * <p>Overall request span using try-with-resources:
 * <pre>
 *      try(Span requestSpan = Tracer.getInstance().startRequestWith*(...)) {
 *          // Traced blocking code for overall request (not asynchronous) goes here ...
 *      }
 *      // No finally block needed to properly complete the overall request span
 * </pre>
 *
 * Subspan using try-with-resources:
 * <pre>
 *      try (Span subspan = Tracer.getInstance().startSubSpan(...)) {
 *          // Traced blocking code for subspan (not asynchronous) goes here ...
 *      }
 *      // No finally block needed to properly complete the subspan
 * </pre>
 *
 * @author Nic Munroe
 * @author Ales Justin
 */
@SuppressWarnings("WeakerAccess")
public class Span implements AutoCloseable {

    private static final Logger logger = LoggerFactory.getLogger(Span.class);

    /** The name of the trace ID field when serializing/deserializing to/from JSON (see {@link #toJSON()} and {@link #fromJSON(String)}). Corresponds to {@link #getTraceId()}. */
    public static final String TRACE_ID_FIELD = "traceId";
    /** The name of the parent span ID field when serializing/deserializing to/from JSON (see {@link #toJSON()} and {@link #fromJSON(String)}). Corresponds to {@link #getParentSpanId()}. */
    public static final String PARENT_SPAN_ID_FIELD = "parentSpanId";
    /** The name of the span ID field when serializing/deserializing to/from JSON (see {@link #toJSON()} and {@link #fromJSON(String)}). Corresponds to {@link #getSpanId()}. */
    public static final String SPAN_ID_FIELD = "spanId";
    /** The name of the span name field when serializing/deserializing to/from JSON (see {@link #toJSON()} and {@link #fromJSON(String)}). Corresponds to {@link #getSpanName()}. */
    public static final String SPAN_NAME_FIELD = "spanName";
    /** The name of the sampleable field when serializing/deserializing to/from JSON (see {@link #toJSON()} and {@link #fromJSON(String)}). Corresponds to {@link #isSampleable()}. */
    public static final String SAMPLEABLE_FIELD = "sampleable";
    /** The name of the user ID field when serializing/deserializing to/from JSON (see {@link #toJSON()} and {@link #fromJSON(String)}). Corresponds to {@link #getUserId()}. */
    public static final String USER_ID_FIELD = "userId";
    /** The name of the span purpose field when serializing to JSON (see {@link #toJSON()}. Corresponds to {@link #getSpanPurpose()}. */
    public static final String SPAN_PURPOSE_FIELD = "spanPurpose";
    /** The name of the start-time-in-epoch-micros field when serializing/deserializing to/from JSON (see {@link #toJSON()} and {@link #fromJSON(String)}). Corresponds to {@link #getSpanStartTimeNanos()}. */
    public static final String START_TIME_EPOCH_MICROS_FIELD = "startTimeEpochMicros";
    /** The name of the duration-in-nanoseconds field when serializing to JSON (see {@link #toJSON()}. Corresponds to {@link #getDurationNanos()}. */
    public static final String DURATION_NANOS_FIELD = "durationNanos";

    private final String traceId;
    private final String spanId;
    private final String parentSpanId;
    private final String spanName;
    private final boolean sampleable;
    private final String userId;
    private final SpanPurpose spanPurpose;
    private final long spanStartTimeEpochMicros;
    private final long spanStartTimeNanos;

    private long spanFinishTimeNanos;

    private Long durationNanos;

    private String cachedJsonRepresentation;

    private String cachedKeyValueRepresentation;

    private Object handle;

    /**
     * Represents a span's intended purpose in the distributed trace. This is not strictly necessary for distributed tracing to work, but it
     * does help give visualizers a hint on the exact relationships between spans and can help sharpen trace analysis.
     */
    public enum SpanPurpose {
        /**
         * Intended for spans that are generated by a server in response to receiving an inbound request from another process. This and {@code CLIENT} are
         * mutually exclusive - if a server request also needs to make an outbound call to a different system then a sub-span should be created specifically
         * to surround the client call (and only the client call) with a {@code CLIENT} span. {@code SERVER} spans are created automatically when you call
         * any of the {@code Tracer.startRequestWith*(...)} methods.
         */
        SERVER,
        /**
         * Intended for spans that represent an outbound/downstream call that crosses network/system/process boundaries. This and {@code SERVER} are mutually
         * exclusive - {@code CLIENT} spans should be used to surround the outbound client call *ONLY*, therefore if you are in a {@code SERVER} span
         * that needs to make an outbound {@code CLIENT} call you should surround the {@code CLIENT} call (and only the client call) with a sub-span.
         * {@code CLIENT} sub-spans can be easily created by calling {@code Tracer.startSubSpan(spanName, SpanPurpose.CLIENT)}
         */
        CLIENT,
        /**
         * Intended for spans that are not related to any outside-the-process behavior - these spans do not receive inbound requests or make outbound requests.
         * They are sub-spans that are 100% contained in the existing process.
         */
        LOCAL_ONLY,
        /**
         * If all else fails then a span will be marked with this. It means the span purpose was unspecified.
         */
        UNKNOWN
    }

    /**
     * <p>
     *  The full constructor allowing you to set all fields representing a span's state. The traceId, spanId, and spanName fields cannot be null (an
     *  {@link IllegalArgumentException} will be thrown if any are null). This method is public to allow full flexibility, however in practice you should use
     *  one of the provided {@link #generateRootSpanForNewTrace(String, SpanPurpose)} or {@link #generateChildSpan(String, SpanPurpose)} helper methods, or the
     *  {@link Builder} if you need more flexibility than the helper methods. If you pass in null for {@code spanPurpose} then {@link SpanPurpose#UNKNOWN}
     *  will be used.
     * </p>
     * WARNING: When deserializing a span that was initially started on a different JVM, you *must* pass in null for {@code spanStartTimeNanos}. Otherwise
     * timing will be completely broken since {@link System#nanoTime()} is not comparable across JVMs.
     */
    public Span(String traceId, String parentSpanId, String spanId, String spanName, boolean sampleable, String userId,
                SpanPurpose spanPurpose, long spanStartTimeEpochMicros, Long spanStartTimeNanos, Long durationNanos
    ) {
        if (traceId == null)
            throw new IllegalArgumentException("traceId cannot be null");

        if (spanId == null)
            throw new IllegalArgumentException("spanId cannot be null");

        if (spanName == null)
            throw new IllegalArgumentException("spanName cannot be null");

        this.traceId = traceId;
        this.spanId = spanId;
        this.parentSpanId = parentSpanId;
        this.spanName = spanName;
        this.sampleable = sampleable;
        this.userId = userId;
        this.spanStartTimeEpochMicros = spanStartTimeEpochMicros;
        if (spanStartTimeNanos == null) {
            // No start time nanos was sent. Calculate it as best we can based on spanStartTimeEpochMicros, the current epoch time, and current nano time.
            long currentTimeEpochMicros = TimeUnit.MILLISECONDS.toMicros(System.currentTimeMillis());
            long currentDurationMicros = currentTimeEpochMicros - spanStartTimeEpochMicros;
            long nanoStartTimeOffset = TimeUnit.MICROSECONDS.toNanos(currentDurationMicros);
            spanStartTimeNanos = System.nanoTime() - nanoStartTimeOffset;
        }
        this.spanStartTimeNanos = spanStartTimeNanos;

        this.durationNanos = durationNanos;

        if (spanPurpose == null)
            spanPurpose = SpanPurpose.UNKNOWN;

        this.spanPurpose = spanPurpose;
    }

    // For deserialization only - this will create an invalid span object and is only here to support deserializers that need a default constructor but set the fields directly (e.g. Jackson)
    protected Span() {
        this("PLACEHOLDER", null, "PLACEHOLDER", "PLACEHOLDER", false, null, SpanPurpose.UNKNOWN, -1, -1L, -1L);
    }

    /**
     * Get span's handle.
     * The handle is meant to simplify any external mapping between {@link Span} and 3rd party libs.
     *
     * @param expectedHandleType the expected handle type
     * @return return casted handle or null if current handle is not of expected type
     */
    public synchronized <T> T getHandle(Class<T> expectedHandleType) {
        if (expectedHandleType == null) {
            throw new IllegalArgumentException("Null expectedHandleType!");
        }

        if (handle == null) {
            return null;
        }

        if (handle instanceof Map) {
            Object value = Map.class.cast(handle).get(expectedHandleType);
            return expectedHandleType.cast(value);
        } else {
            return (expectedHandleType.isInstance(handle) ? expectedHandleType.cast(handle) : null);
        }
    }

    /**
     * Set handle.
     *
     * Can be anything, see {@link Span#getHandle(Class)} for more info.
     * If handle is already set, we change it to {@link Map},
     * with keys as handles classes, and handles as values.
     *
     * If handle parameter is null, do nothing.
     *
     * @param handle the handle
     */
    public synchronized void setHandle(Object handle) {
        if (handle == null) {
            return;
        }

        Object currentHandle = this.handle;
        if (currentHandle != null) {
            if (!(currentHandle instanceof Map)) {
                this.handle = new HashMap<>(Collections.<Class<?>, Object>singletonMap(currentHandle.getClass(), currentHandle));
            }
            //noinspection unchecked
            Map.class.cast(this.handle).put(handle.getClass(), handle);
        } else {
            this.handle = handle;
        }
    }

    /**
     * @param spanName The {@link Span#getSpanName()} to initialize the builder with.
     * @param spanPurpose The {@link SpanPurpose} to initialize the builder with. See the javadocs for {@link SpanPurpose} for full details on what each enum option
     *                    means. If you pass in null for this then {@link SpanPurpose#UNKNOWN} will be used.
     * @return A builder setup to generate an uncompleted root span for a new trace. Since it is a root span it will have a null {@link #getParentSpanId()}.
     *          If no further changes are made to the returned builder then when {@link Builder#build()} is called the resulting span's {@link #getTraceId()}
     *          and {@link #getSpanId()} will be randomly generated, and {@link #getSpanStartTimeEpochMicros()} and {@link #getSpanStartTimeNanos()} will be set to
     *          the appropriate values based on when {@link Builder#build()} is called. If further tweaks to the span are necessary you can adjust the builder
     *          before calling {@link Builder#build()} (e.g. setting a user ID via {@link Builder#withUserId(String)}.
     */
    public static Builder generateRootSpanForNewTrace(String spanName, SpanPurpose spanPurpose) {
        return newBuilder(spanName, spanPurpose);
    }

    /**
     * @param spanName The {@link Span#getSpanName()} to use for the new child sub-span.
     * @param spanPurpose The {@link SpanPurpose} for the new child span. See the javadocs for {@link SpanPurpose} for full details on what each enum option
     *                    means. If you pass in null for this then {@link SpanPurpose#UNKNOWN} will be used.
     * @return A new uncompleted span representing a child of this instance. The returned instance's {@link #getParentSpanId()} will be this instance's
     *          {@link #getSpanId()}, its {@link #getSpanName()} will be the given value, its {@link #getSpanId()} will be randomly generated, and its
     *          {@link #getSpanStartTimeEpochMicros()} and {@link #getSpanStartTimeNanos()} values will be set to the appropriate values based on when this
     *          method is called. It will share this instance's {@link #getTraceId()}, {@link #isSampleable()}, and {@link #getUserId()} values.
     */
    public Span generateChildSpan(String spanName, SpanPurpose spanPurpose) {
        return Span.newBuilder(this)
                   .withParentSpanId(this.spanId)
                   .withSpanName(spanName)
                   .withSpanId(TraceAndSpanIdGenerator.generateId())
                   .withSpanStartTimeEpochMicros(TimeUnit.MILLISECONDS.toMicros(System.currentTimeMillis()))
                   .withSpanStartTimeNanos(System.nanoTime())
                   .withDurationNanos(null)
                   .withSpanPurpose(spanPurpose)
                   .build();
    }

    /**
     * @param spanName The {@link Span#getSpanName()} to initialize the builder with.
     * @param spanPurpose The {@link SpanPurpose} to initialize the builder with. See the javadocs for {@link SpanPurpose} for full details on what each enum
     *                    option means. If you pass in null for this then {@link SpanPurpose#UNKNOWN} will be used.
     * @return A new span builder with nothing populated beyond the given span name. Based on the behavior of {@link Builder#build()}, if you were to build it
     *          immediately you'd end up with an uncompleted root span for a new trace (same behavior as {@link #generateRootSpanForNewTrace(String, SpanPurpose)}.
     *          You are free to adjust any values before building however, so you can setup the builder to represent any span you want.
     */
    public static Builder newBuilder(String spanName, SpanPurpose spanPurpose) {
        return new Builder(spanName, spanPurpose);
    }

    /**
     * @return A new span builder that has all its fields copied from the given {@link Span}. If you call {@link Builder#build()} immediately on the returned builder you'd
     *          end up with an exact duplicate of the given span.
     */
    public static Builder newBuilder(Span copy) {
        Builder builder = new Builder(copy.spanName, copy.spanPurpose);
        builder.traceId = copy.traceId;
        builder.spanId = copy.spanId;
        builder.parentSpanId = copy.parentSpanId;
        builder.sampleable = copy.sampleable;
        builder.userId = copy.userId;
        builder.spanStartTimeEpochMicros = copy.spanStartTimeEpochMicros;
        builder.spanStartTimeNanos = copy.spanStartTimeNanos;
        builder.durationNanos = copy.durationNanos;
        return builder;
    }

    /**
     * @return The ID associated with the overall distributed trace - a.k.a. the trace tree ID. All spans in a distributed trace will share the same trace ID.
     *          Don't confuse this with {@link #getSpanId()}, which is the ID for an individual span of work as part of the larger distributed trace. This will never
     *          be null. NOTE: By convention this will likely be a 16 character lowercase hex-encoded 64-bit long-integer value
     *          (see {@link TraceAndSpanIdGenerator#generateId()} for details).
     */
    public String getTraceId() {
        return traceId;
    }

    /**
     * @return The ID for this span of work in the distributed trace. Don't confuse this with the {@link #getTraceId()}, which is the ID associated with the overall
     *          distributed trace and is the same for all spans in a trace. Also don't confuse this with {@link #getParentSpanId()}, which is the ID of the span that spawned
     *          this span instance (the logical "parent" of this span). This will never be null. NOTE: By convention this will likely be a 16 character
     *          lowercase hex-encoded 64-bit long-integer value (see {@link TraceAndSpanIdGenerator#generateId()} for details).
     */
    public String getSpanId() {
        return spanId;
    }

    /**
     * @return The ID of the span that spawned this span instance (the logical "parent" of this span), or null if no such parent exists. If this returns null then this
     *          span is the "root span" for the distributed trace - the ultimate ancestor of all other spans in the trace tree.
     *          NOTE: By convention this will likely be a 16 character lowercase hex-encoded 64-bit long-integer value
     *          (see {@link TraceAndSpanIdGenerator#generateId()} for details).
     */
    public String getParentSpanId() {
        return parentSpanId;
    }

    /**
     * @return The human-readable name for this span. This will never be null.
     */
    public String getSpanName() {
        return spanName;
    }

    /**
     * @return True if this span is sampleable and should be output to the logging/span collection system, false otherwise.
     */
    public boolean isSampleable() {
        return sampleable;
    }

    /**
     * @return The ID of the user logically associated with this span, or null if no such user ID exists or is appropriate.
     */
    public String getUserId() {
        return userId;
    }

    /**
     * @return The start timestamp of the span in epoch microseconds (*not* milliseconds!). NOTE: Due to java limitations this currently only has millisecond
     *          resolution (i.e. this was generated by converting {@link System#currentTimeMillis()} to microseconds), however other timestamps generated
     *          for this span will be generated relative to this starting timestamp using microsecond resolution by utilizing {@link System#nanoTime()} to
     *          calculate differences.
     */
    public long getSpanStartTimeEpochMicros() {
        return spanStartTimeEpochMicros;
    }

    /**
     * @return The start time of the span - calculated by calling {@link System#nanoTime()} when the constructor for this instance was called. WARNING: As per the
     *          javadocs for {@link System#nanoTime()} this value is *NOT* an epoch value like {@link System#currentTimeMillis()} - it is only usable when
     *          comparing against other {@link System#nanoTime()} calls performed on the *same JVM*.
     */
    public long getSpanStartTimeNanos() {
        return spanStartTimeNanos;
    }

    /**
     * @return The purpose of this span. This will never be null - if the purpose is unknown then {@link SpanPurpose#UNKNOWN} will be returned. See the javadocs
     *          for {@link SpanPurpose} for information on what each enum option means.
     */
    public SpanPurpose getSpanPurpose() {
        return spanPurpose;
    }

    /**
     * Indicates that this {@link Span} is completed/finished/finalized and sets {@link #getDurationNanos()} to be {@link System#nanoTime()} minus
     * {@link #getSpanStartTimeNanos()}. After this is called then {@link #isCompleted()} will return true and {@link #getDurationNanos()} will return
     * the value calculated here. An {@link IllegalStateException} will be thrown if this method is called after the span has already been completed.
     * <p/>
     * NOTE: This is intentionally package scoped to make sure completions and logging/span output logic happens centrally through {@link Tracer}.
     */
    void complete() {
        if (this.durationNanos != null)
            throw new IllegalStateException("This Span is already completed.");

        this.durationNanos = (spanFinishTimeNanos > 0 ? spanFinishTimeNanos : System.nanoTime()) - spanStartTimeNanos;
        // We need to recalculate the JSON and/or key/value representation(s) of this span now that the state of the span has been modified.
        // By setting a cached value to null it will be regenerated the next time it is requested.
        cachedJsonRepresentation = null;
        cachedKeyValueRepresentation = null;
    }

    /**
     * @return true if {@link #complete()} has been called on this instance (representing a completed/finished/finalized span), false otherwise.
     */
    public boolean isCompleted() {
        return durationNanos != null;
    }

    /**
     * @return The amount of time in nanoseconds between when this span was started and when it was completed - this will return null if {@link #isCompleted()} is false.
     *          You must call {@link #complete()} to complete the span and populate the field this method returns.
     */
    public Long getDurationNanos() {
        return durationNanos;
    }

    /**
     * @return this span's *current* status relative to {@link Tracer} on the current thread at the time this method is
     * called. This status is recalculated every time this method is called and is only relevant/correct until {@link
     * Tracer}'s state is modified (i.e. by starting a subspan, completing a span, using any of the asynchronous helper
     * methods to modify the span stack in any way, etc), so it should only be considered relevant for the moment the
     * call is made.
     *
     * <p>NOTE: Most app-level developers should not need to worry about this at all.
     */
    public TracerManagedSpanStatus getCurrentTracerManagedSpanStatus() {
        return Tracer.getInstance().getCurrentManagedStatusForSpan(this);
    }

    /**
     * @return The JSON representation of this span. See {@link #toJSON()}.
     */
    @Override
    public String toString() {
        return toJSON();
    }

    /**
     * @return A comma-delimited {@code key=value} string based on this {@link Span} instance.
     *         NOTE: The {@link #DURATION_NANOS_FIELD} field will be added only if {@link #isCompleted()} is true. This lets you call this method at any time
     *         and only the relevant data will be output in the returned String (e.g. in case you want to log info about the span before it has been completed).
     */
    public String toKeyValueString() {
        if (cachedKeyValueRepresentation == null)
            cachedKeyValueRepresentation = calculateKeyValueString();

        return cachedKeyValueRepresentation;
    }

    /**
     * Calculates and returns the key=value representation of this span instance.
     */
    protected String calculateKeyValueString() {
        StringBuilder builder = new StringBuilder();

        builder.append(TRACE_ID_FIELD).append("=").append(traceId);
        builder.append(",").append(PARENT_SPAN_ID_FIELD).append("=").append(parentSpanId);
        builder.append(",").append(SPAN_ID_FIELD).append("=").append(spanId);
        builder.append(",").append(SPAN_NAME_FIELD).append("=").append(spanName);
        builder.append(",").append(SAMPLEABLE_FIELD).append("=").append(sampleable);
        builder.append(",").append(USER_ID_FIELD).append("=").append(userId);
        builder.append(",").append(SPAN_PURPOSE_FIELD).append("=").append(spanPurpose.name());
        builder.append(",").append(START_TIME_EPOCH_MICROS_FIELD).append("=").append(spanStartTimeEpochMicros);
        if (isCompleted()) {
            builder.append(",").append(DURATION_NANOS_FIELD).append("=").append(durationNanos);
        }

        return builder.toString();
    }

    /**
     * Put span's info into map.
     *
     * @return span's info as a map
     */
    public Map<String, Object> toMap() {
        Map<String, Object> map = new HashMap<>();

        map.put(TRACE_ID_FIELD, traceId);
        map.put(PARENT_SPAN_ID_FIELD, parentSpanId);
        map.put(SPAN_ID_FIELD, spanId);
        map.put(SPAN_NAME_FIELD, spanName);
        map.put(SAMPLEABLE_FIELD, sampleable);
        map.put(USER_ID_FIELD, userId);
        map.put(SPAN_PURPOSE_FIELD, spanPurpose.name());
        map.put(START_TIME_EPOCH_MICROS_FIELD, spanStartTimeEpochMicros);
        if (isCompleted()) {
            map.put(DURATION_NANOS_FIELD, durationNanos);
        }

        return map;
    }

    /**
     * @return The {@link Span} represented by the given key/value string, or null if a proper span could not be deserialized from the given string.
     *          <b>WARNING:</b> This method assumes the string you're trying to deserialize originally came from
     *          {@link #toKeyValueString()}. This assumption allows it to be as fast as possible, not worry about syntactically-correct-but-annoying-to-deal-with whitespace,
     *          not have to use a third party utility, etc.
     */
    public static Span fromKeyValueString(String keyValueStr) {
        try {
            // Create a map of keys to values.
            Map<String, String> map = new HashMap<>();

            // Split on the commas that separate the key/value pairs.
            String[] fieldPairs = keyValueStr.split(",");
            for (String fieldPair : fieldPairs) {
                // Split again on the equals character that separate the field's key from its value.
                String[] keyVal = fieldPair.split("=");
                map.put(keyVal[0], keyVal[1]);
            }

            return fromKeyValueMap(map);
        } catch (Exception e) {
            logger.error("Error extracting Span from key/value string. Defaulting to null. bad_span_key_value_string={}", keyValueStr, e);
            return null;
        }
    }

    /**
     * @return A JSON string based on this {@link Span} instance.
     *         NOTE: The {@link #DURATION_NANOS_FIELD} field will be added only if {@link #isCompleted()} is true. This lets you call this method at any time
     *         and only the relevant data will be output in the returned JSON (e.g. in case you want to log info about the span before it has been completed).
     */
    public String toJSON() {
        // Profiling shows this JSON creation to generate a lot of garbage in certain situations, so we should cache the result.
        if (cachedJsonRepresentation == null)
            cachedJsonRepresentation = calculateJson();

        return cachedJsonRepresentation;
    }

    /**
     * Calculates and returns the JSON representation of this span instance. We build this manually ourselves to avoid pulling in an extra dependency
     * (e.g. Jackson) just for building a simple JSON string.
     */
    protected String calculateJson() {
        StringBuilder builder = new StringBuilder();

        builder.append("{\"").append(TRACE_ID_FIELD).append("\":\"").append(traceId);
        builder.append("\",\"").append(PARENT_SPAN_ID_FIELD).append("\":\"").append(parentSpanId);
        builder.append("\",\"").append(SPAN_ID_FIELD).append("\":\"").append(spanId);
        builder.append("\",\"").append(SPAN_NAME_FIELD).append("\":\"").append(spanName);
        builder.append("\",\"").append(SAMPLEABLE_FIELD).append("\":\"").append(sampleable);
        builder.append("\",\"").append(USER_ID_FIELD).append("\":\"").append(userId);
        builder.append("\",\"").append(SPAN_PURPOSE_FIELD).append("\":\"").append(spanPurpose.name());
        builder.append("\",\"").append(START_TIME_EPOCH_MICROS_FIELD).append("\":\"").append(spanStartTimeEpochMicros);
        if (isCompleted()) {
            builder.append("\",\"").append(DURATION_NANOS_FIELD).append("\":\"").append(durationNanos);
        }
        builder.append("\"}");

        return builder.toString();
    }

    /**
     * @return The {@link Span} represented by the given JSON string, or null if a proper span could not be deserialized from the given string.
     *          <b>WARNING:</b> This method assumes the JSON you're trying to deserialize originally came from {@link #toJSON()}.
     *          This assumption allows it to be as fast as possible, not have to check for malformed JSON, not worry about syntactically-correct-but-annoying-to-deal-with whitespace,
     *          not have to use a third party utility like Jackson, etc.
     */
    public static Span fromJSON(String json) {
        try {
            // Create a map of JSON field keys to values.
            Map<String, String> map = new HashMap<>();

            // Strip off the {" and "} at the beginning/end.
            String innerJsonCore = json.substring(2, json.length() - 2);
            // Split on the doublequotes-comma-doublequotes that separate the fields.
            String[] fieldPairs = innerJsonCore.split("\",\"");
            for (String fieldPair : fieldPairs) {
                // Split again on the doublequotes-colon-doublequotes that separate the field's key from its value. At this point all double-quotes have been stripped off
                // and we can just map the key to the value.
                String[] keyVal = fieldPair.split("\":\"");
                map.put(keyVal[0], keyVal[1]);
            }

            return fromKeyValueMap(map);
        } catch (Exception e) {
            logger.error("Error extracting Span from JSON. Defaulting to null. bad_span_json={}", json, e);
            return null;
        }
    }

    /**
     *
     * @param map the map of Span's keys and values
     * @return The {@link Span} represented by the given map parameter
     */
    public static Span fromKeyValueMap(Map<String, String> map) {
        // Use the map to get the field values for the span.
        String traceId = nullSafeGetString(map, TRACE_ID_FIELD);
        String spanId = nullSafeGetString(map, SPAN_ID_FIELD);
        String parentSpanId = nullSafeGetString(map, PARENT_SPAN_ID_FIELD);
        String spanName = nullSafeGetString(map, SPAN_NAME_FIELD);
        Boolean sampleable = nullSafeGetBoolean(map, SAMPLEABLE_FIELD);
        if (sampleable == null)
            throw new IllegalStateException("Unable to parse " + SAMPLEABLE_FIELD + " from JSON");
        String userId = nullSafeGetString(map, USER_ID_FIELD);
        Long startTimeEpochMicros = nullSafeGetLong(map, START_TIME_EPOCH_MICROS_FIELD);
        if (startTimeEpochMicros == null)
            throw new IllegalStateException("Unable to parse " + START_TIME_EPOCH_MICROS_FIELD + " from JSON");
        Long durationNanos = nullSafeGetLong(map, DURATION_NANOS_FIELD);
        SpanPurpose spanPurpose = nullSafeGetSpanPurpose(map, SPAN_PURPOSE_FIELD);
        return new Span(traceId, parentSpanId, spanId, spanName, sampleable, userId, spanPurpose, startTimeEpochMicros, null, durationNanos);
    }

    private static String nullSafeGetString(Map<String, String> map, String key) {
        String value = map.get(key);
        if (value == null || value.equals("null"))
            return null;

        return value;
    }

    private static Long nullSafeGetLong(Map<String, String> map, String key) {
        String value = nullSafeGetString(map, key);
        if (value == null)
            return null;

        return Long.parseLong(value);
    }

    private static Boolean nullSafeGetBoolean(Map<String, String> map, String key) {
        String value = nullSafeGetString(map, key);
        if (value == null)
            return null;

        return Boolean.parseBoolean(value);
    }

    private static SpanPurpose nullSafeGetSpanPurpose(Map<String, String> map, String key) {
        String value = nullSafeGetString(map, key);
        if (value == null)
            return null;

        try {
            return SpanPurpose.valueOf(value);
        }
        catch(Exception ex) {
            logger.warn("Unable to parse \"{}\" to a SpanPurpose enum. Received exception: {}", value, ex.toString());
            return null;
        }
    }

    /**
     * Handle span's scope.
     * e.g. if it was handled manually before, push it appropriately onto stack.
     */
    public void handleScope() {
        Tracer tracer = Tracer.getInstance();
        tracer.manageSpan(this);
    }

    /**
     * Handles the implementation of {@link AutoCloseable#close()} for spans to allow them to be used in
     * try-with-resources statements.
     * <ul>
     *     <li>
     *         If this span is already completed ({@link #isCompleted()} returns true) then an error will be logged
     *         and nothing will be done.
     *     </li>
     *     <li>
     *         If this span is the current span ({@link Tracer#getCurrentSpan()} equals the given span), then {@link
     *         Tracer#completeRequestSpan()} or {@link Tracer#completeSubSpan()} will be called, whichever is
     *         appropriate.
     *     </li>
     *     <li>
     *         If this span is *not* the current span ({@link Tracer#getCurrentSpan()} does not equal this span), then
     *         this may or may not be an error depending on whether this span is managed by {@link Tracer} or not.
     *         <ul>
     *             <li>
     *                 If this span is managed by {@link Tracer} (i.e. it is contained in the span stack somewhere even
     *                 though it's not the current span) then this is a wingtips usage error - this span should not be
     *                 completed yet - and an error will be logged and this span will be completed and logged to the
     *                 "invalid span logger".
     *             </li>
     *             <li>
     *                 Otherwise this span is not managed by us, and since there may be valid use cases for manually
     *                 managing spans we must assume the call was intentional. No error will be logged, and this span
     *                 will be completed and logged to the "valid span logger".
     *             </li>
     *             <li>
     *                 In either case, {@link Tracer}'s current span stack and MDC info will be left untouched if
     *                 this span is not the current span.
     *             </li>
     *         </ul>
     *     </li>
     * </ul>
     */
    @Override
    public void close() {
        Tracer.getInstance().handleSpanCloseMethod(this);
    }

    /**
     * Close span with explicit finish time (in nanos).
     * See {@link Span#close()} for more details.
     *
     * @param spanFinishTimeNanos span finish time (in nanos)
     */
    public void close(long spanFinishTimeNanos) {
        this.spanFinishTimeNanos = spanFinishTimeNanos;
        close();
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) {
            return true;
        }
        if (!(o instanceof Span)) {
            return false;
        }
        Span span = (Span) o;
        return sampleable == span.sampleable &&
               spanStartTimeEpochMicros == span.spanStartTimeEpochMicros &&
               spanPurpose == span.spanPurpose &&
               Objects.equals(traceId, span.traceId) &&
               Objects.equals(spanId, span.spanId) &&
               Objects.equals(parentSpanId, span.parentSpanId) &&
               Objects.equals(spanName, span.spanName) &&
               Objects.equals(userId, span.userId) &&
               Objects.equals(durationNanos, span.durationNanos);
    }

    @Override
    public int hashCode() {
        return Objects.hash(traceId, spanId, parentSpanId, spanName, sampleable, userId, spanPurpose, spanStartTimeEpochMicros, durationNanos);
    }

    /**
     * Builder for creating {@link Span} objects.
     * <p/>
     * IMPORTANT NOTE: Calling {@link #build()} will choose sensible defaults for {@code traceId} and {@code spanId} if they are null when {@link #build()} is called by
     *                 calling {@link TraceAndSpanIdGenerator#generateId()} for each, and will default {@code spanStartTimeNanos} to {@link System#nanoTime()}.
     *                 This allows you to generate a fresh "root" span by creating a new instance of this builder and immediately calling {@link #build()}
     *                 without any further parameters being set. The simplest way to generate a child span is to get your hands on the parent span and call
     *                 {@link Span#generateChildSpan(String, SpanPurpose)} rather than use this builder directly. For any other use cases you can use this
     *                 builder to set any {@link Span} fields you want manually.
     */
    public static final class Builder {
        private static final Logger builderLogger = LoggerFactory.getLogger(Builder.class);

        private String traceId;
        private String spanId;
        private String parentSpanId;
        private String spanName;
        private boolean sampleable = true;
        private String userId;
        private Long spanStartTimeEpochMicros;
        private Long spanStartTimeNanos;
        private Long durationNanos;
        private SpanPurpose spanPurpose;

        private Builder(String spanName, SpanPurpose spanPurpose) {
            this.spanName = spanName;
            this.spanPurpose = spanPurpose;
        }

        /**
         * Sets the The ID associated with the overall distributed trace - a.k.a. the trace tree ID. All spans in a distributed trace will share the same trace ID.
         * Don't confuse this with {@link #withSpanId(String)}, which sets the ID for an individual span of work as part of the larger distributed trace.
         * <p/>
         * IMPORTANT NOTE: {@link Span}s are not allowed to have a null trace ID, so if this is null when {@link #build()} is called then the {@link Span} returned by
         *                 {@link #build()} will have its trace ID defaulted to a new random ID using {@link TraceAndSpanIdGenerator#generateId()}.
         *
         * @param traceId the {@code traceId} to set
         * @return a reference to this Builder
         */
        public Builder withTraceId(String traceId) {
            this.traceId = traceId;
            return this;
        }

        /**
         * Sets the ID for this span of work in the distributed trace. Don't confuse this with {@link #withTraceId(String)}, which sets the ID associated with the overall
         * distributed trace and is the same for all spans in a trace. Also don't confuse this with {@link #getParentSpanId()}, which is the ID of the span that spawned
         * this span instance (the logical "parent" of this span).
         * <p/>
         * IMPORTANT NOTE: {@link Span}s are not allowed to have a null span ID, so if this is null when {@link #build()} is called then the {@link Span} returned by
         *                 {@link #build()} will have its span ID defaulted to a new random ID using {@link TraceAndSpanIdGenerator#generateId()}.
         *
         * @param spanId the {@code spanId} to set
         * @return a reference to this Builder
         */
        public Builder withSpanId(String spanId) {
            this.spanId = spanId;
            return this;
        }

        /**
         * Sets the ID of the span that spawned this span instance (the logical "parent" of this span), or pass in null if no such parent exists. If you pass in null then
         * this instance will be a root span for the distributed trace - the ultimate ancestor of all other spans in the trace tree.
         *
         * @param parentSpanId the {@code parentSpanId} to set
         * @return a reference to this Builder
         */
        public Builder withParentSpanId(String parentSpanId) {
            this.parentSpanId = parentSpanId;
            return this;
        }

        /**
         * Sets the human-readable name for this span. This should never be null - if you set this to null and call {@link #build()} then an {@link IllegalArgumentException} will
         * be thrown.
         *
         * @param spanName the {@code spanName} to set
         * @return a reference to this Builder
         */
        public Builder withSpanName(String spanName) {
            this.spanName = spanName;
            return this;
        }

        /**
         * Set this to true if this span is sampleable and should be output to the logging/span collection system, false otherwise. This defaults to true.
         *
         * @param sampleable the {@code sampleable} value to set
         * @return a reference to this Builder
         */
        public Builder withSampleable(boolean sampleable) {
            this.sampleable = sampleable;
            return this;
        }

        /**
         * Sets the ID of the user logically associated with this span, or pass in null if no such user ID exists or is appropriate.
         *
         * @param userId the {@code userId} to set
         * @return a reference to this Builder
         */
        public Builder withUserId(String userId) {
            this.userId = userId;
            return this;
        }

        /**
         * <p>
         * Sets the start timestamp in microseconds since the epoch for this span (*not* milliseconds), or pass in null if this is a new span and
         * you want this value calculated automatically when {@link #build()} is called.
         * </p>
         * NOTE: Since Java 7 does not have a reliable way to calculate this value accurately we generally just get as close as we can by turning
         * {@link System#currentTimeMillis()} into microseconds. That means the start timestamp only has millisecond resolution.
         *
         * @param spanStartTimeEpochMicros the {@code spanStartTimeEpochMicros} to set
         * @return a reference to this Builder
         */
        public Builder withSpanStartTimeEpochMicros(Long spanStartTimeEpochMicros) {
            this.spanStartTimeEpochMicros = spanStartTimeEpochMicros;
            return this;
        }

        /**
         * <p>
         *     <b>TLDR; Passing in null (or not calling this method at all) is always a safe option - when in doubt leave this null!</b>
         * </p>
         * <p>
         *  Sets the start time of the span in nanoseconds. This value is used when calculating {@link #getDurationNanos()}. If this is left null then one of
         *  two things will be done to generate it depending on the situation:
         *  <ol>
         *      <li>
         *          If {@link #withSpanStartTimeEpochMicros(Long)} is null - this indicates a brand new span is being created on this JVM. This value will be
         *          set to {@link System#nanoTime()} when {@link #build()} is called. This leads to {@link #getDurationNanos()} being accurate to the
         *          nanosecond, however it is only possible to do this when you start and complete a given span on the same JVM.
         *      </li>
         *      <li>
         *          If {@link #withSpanStartTimeEpochMicros(Long)} is *not* null - this indicates you're deserializing a span that was created on a different
         *          JVM. This nano start time value will then be inferred based on the span's starting timestamp ({@code spanStartTimeEpochMicros}),
         *          {@link System#currentTimeMillis()}, and {@link System#nanoTime()}. You will lose a little bit of duration resolution compared with starting
         *          and completing a span on the same JVM, but it will be reasonable (guaranteed less than 1 millisecond of error).
         *      </li>
         *  </ol>
         *  This means you should only pass in a non-null value to this method when you are recreating/deserializing
         *  a span that was originally created on this exact same JVM instance. Since this is an unusual use case, you will almost always want to pass in null
         *  (or not call this method at all).
         * </p>
         *
         * @param spanStartTimeNanos the {@code spanStartTimeNanos} to set
         * @return a reference to this Builder
         */
        public Builder withSpanStartTimeNanos(Long spanStartTimeNanos) {
            this.spanStartTimeNanos = spanStartTimeNanos;
            return this;
        }

        /**
         * <p>
         *  Sets the duration of the span in nanoseconds, or null if this {@link Span} should not be considered {@link Span#isCompleted()} yet.
         * </p>
         * <p>
         *  NOTE: Under most circumstances you will want this to be null (which is the default) since there are not many use cases where you need to create an
         *  already-completed {@link Span}.
         * </p>
         *
         * @param durationNanos the {@code durationNanos} to set
         * @return a reference to this Builder
         */
        public Builder withDurationNanos(Long durationNanos) {
            this.durationNanos = durationNanos;
            return this;
        }

        /**
         * Sets the {@link SpanPurpose} for this span. See the javadocs on that class for details on what each enum option means. Passing in null is equivalent
         * to {@link SpanPurpose#UNKNOWN}.
         *
         * @param spanPurpose the {@code spanPurpose} to set
         * @return a reference to this Builder
         */
        public Builder withSpanPurpose(SpanPurpose spanPurpose) {
            this.spanPurpose = spanPurpose;
            return this;
        }

        /**
         * <p>
         *  Returns a {@link Span} built from the parameters set via the various {@code with*(...)} methods on this builder instance.
         * </p>
         * <p>
         *  IMPORTANT NOTE: {@link Span} objects are not allowed to have null {@link Span#getTraceId()}, {@link Span#getSpanId()}, or
         *  {@link Span#getSpanStartTimeEpochMicros()}, and there are sensible defaults we can set for those values when creating a new span, so if any of them
         *  are null when this method is called it is assumed you are creating a new span and they will be set to the following:
         *  <ul>
         *      <li>{@code traceId} is defaulted to {@link TraceAndSpanIdGenerator#generateId()}</li>
         *      <li>{@code spanId} is defaulted to {@link TraceAndSpanIdGenerator#generateId()}</li>
         *      <li>{@code spanStartTimeEpochMicros} is defaulted to {@link System#currentTimeMillis()} converted to microseconds</li>
         *      <ul>
         *          <li>Side note - {@code spanStartTimeNanos} is calculated based on the rules described in {@link #withSpanStartTimeNanos(Long)}</li>
         *      </ul>
         *  </ul>
         *  Span name is also not allowed to be null, but since there is no sensible default for that value an {@link IllegalArgumentException} will be thrown
         *  if span name is null when this method is called.
         * </p>
         *
         * @return a {@code Span} built with parameters of this {@code Span.Builder}
         */
        public Span build() {
            if (traceId == null)
                traceId = TraceAndSpanIdGenerator.generateId();

            if (spanId == null)
                spanId = TraceAndSpanIdGenerator.generateId();

            if (spanStartTimeEpochMicros == null) {
                spanStartTimeEpochMicros = TimeUnit.MILLISECONDS.toMicros(System.currentTimeMillis());
                if (spanStartTimeNanos != null) {
                    // The nano start time was set but the start time in epoch microseconds was *not*.
                    //      This makes no sense, so we'll null out the nano start and log a warning.
                    builderLogger.warn("The builder was setup with a null spanStartTimeEpochMicros and non-null spanStartTimeNanos. This makes no sense "
                                       + "(if you have a nano start time then you should also have the epoch micros start time), so the nano start time "
                                       + "passed into this builder will be ignored and calculated fresh along with the epoch micros start timestamp.");
                    spanStartTimeNanos = null;
                }
            }

            if (spanStartTimeNanos == null)
                spanStartTimeNanos = System.nanoTime();

            return new Span(traceId, parentSpanId, spanId, spanName, sampleable, userId, spanPurpose, spanStartTimeEpochMicros, spanStartTimeNanos, durationNanos);
        }
    }
}
