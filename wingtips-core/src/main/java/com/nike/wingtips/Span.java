package com.nike.wingtips;

import java.io.Closeable;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.Map;
import java.util.Objects;
import java.util.concurrent.TimeUnit;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.nike.wingtips.util.SpanParser;
import com.nike.wingtips.util.TracerManagedSpanStatus;

/**
 * Represents some logical "unit of work" that is part of the larger distributed trace. A given request's trace tree is made up of all the spans with the same {@link #traceId}
 * and the spans are connected via parent-child relationship. The first span in the trace tree covers the entire distributed trace - it is often referred to as the root span.
 *
 * <p>For any given service call in a distributed trace there is usually one span covering the full call; that service-level span is started when a request first hits the service
 * and {@link #complete()} is called when the response is sent to the caller, and at that point the resulting completed span is logged or otherwise sent to a span collector
 * of some sort so the span's data can be used later for investigations/aggregations/statistics.
 *
 * <p>Extra "sub-spans" can be generated by a service if it wants additional tracing around specific functions inside the service. One sub-span example might be to create a sub-span
 * in service A when it makes a downstream call to service B. You could then subtract {@link #getDurationNanos()} for service B's service-level span from the time spent in
 * service A's downstream call span to determine what the network lag was for that call.
 *
 * <p>Spans support Java try-with-resources statements to help guarantee proper usage in blocking/non-async scenarios
 * (for asynchronous scenarios please refer to <a href="https://github.com/Nike-Inc/wingtips#async_usage">the
 * asynchronous usage section of the Wingtips readme</a>). Here are some examples.
 *
 * <p>Overall request span using try-with-resources:
 * <pre>
 *      try(Span requestSpan = Tracer.getInstance().startRequestWith*(...)) {
 *          // Traced blocking code for overall request (not asynchronous) goes here ...
 *      }
 *      // No finally block needed to properly complete the overall request span
 * </pre>
 *
 * Subspan using try-with-resources:
 * <pre>
 *      try (Span subspan = Tracer.getInstance().startSubSpan(...)) {
 *          // Traced blocking code for subspan (not asynchronous) goes here ...
 *      }
 *      // No finally block needed to properly complete the subspan
 * </pre>
 *
 * @author Nic Munroe
 */
@SuppressWarnings("WeakerAccess")
public class Span implements Closeable {

    private static final Logger logger = LoggerFactory.getLogger(Span.class);

    private final String traceId;
    private final String spanId;
    private final String parentSpanId;
    private final String spanName;
    private final boolean sampleable;
    private final String userId;
    private final SpanPurpose spanPurpose;
    private final long spanStartTimeEpochMicros;
    private final long spanStartTimeNanos;
    
    private Long durationNanos;
    private Map<String,String> tags = new LinkedHashMap<String,String>(0);
    
    private String cachedJsonRepresentation;

    private String cachedKeyValueRepresentation;

    /**
     * Represents a span's intended purpose in the distributed trace. This is not strictly necessary for distributed tracing to work, but it
     * does help give visualizers a hint on the exact relationships between spans and can help sharpen trace analysis.
     */
    public enum SpanPurpose {
        /**
         * Intended for spans that are generated by a server in response to receiving an inbound request from another process. This and {@code CLIENT} are
         * mutually exclusive - if a server request also needs to make an outbound call to a different system then a sub-span should be created specifically
         * to surround the client call (and only the client call) with a {@code CLIENT} span. {@code SERVER} spans are created automatically when you call
         * any of the {@code Tracer.startRequestWith*(...)} methods.
         */
        SERVER,
        /**
         * Intended for spans that represent an outbound/downstream call that crosses network/system/process boundaries. This and {@code SERVER} are mutually
         * exclusive - {@code CLIENT} spans should be used to surround the outbound client call *ONLY*, therefore if you are in a {@code SERVER} span
         * that needs to make an outbound {@code CLIENT} call you should surround the {@code CLIENT} call (and only the client call) with a sub-span.
         * {@code CLIENT} sub-spans can be easily created by calling {@code Tracer.startSubSpan(spanName, SpanPurpose.CLIENT)}
         */
        CLIENT,
        /**
         * Intended for spans that are not related to any outside-the-process behavior - these spans do not receive inbound requests or make outbound requests.
         * They are sub-spans that are 100% contained in the existing process.
         */
        LOCAL_ONLY,
        /**
         * If all else fails then a span will be marked with this. It means the span purpose was unspecified.
         */
        UNKNOWN
    }

    /**
     * <p>
     *  The full constructor allowing you to set all fields representing a span's state. The traceId, spanId, and spanName fields cannot be null (an
     *  {@link IllegalArgumentException} will be thrown if any are null). This method is public to allow full flexibility, however in practice you should use
     *  one of the provided {@link #generateRootSpanForNewTrace(String, SpanPurpose)} or {@link #generateChildSpan(String, SpanPurpose)} helper methods, or the
     *  {@link Builder} if you need more flexibility than the helper methods. If you pass in null for {@code spanPurpose} then {@link SpanPurpose#UNKNOWN}
     *  will be used.
     * </p>
     * WARNING: When deserializing a span that was initially started on a different JVM, you *must* pass in null for {@code spanStartTimeNanos}. Otherwise
     * timing will be completely broken since {@link System#nanoTime()} is not comparable across JVMs.
     */
    public Span(String traceId, String parentSpanId, String spanId, String spanName, boolean sampleable, String userId,
                SpanPurpose spanPurpose, long spanStartTimeEpochMicros, Long spanStartTimeNanos, Long durationNanos,
                Map<String,String> tags
    ) {
        if (traceId == null)
            throw new IllegalArgumentException("traceId cannot be null");

        if (spanId == null)
            throw new IllegalArgumentException("spanId cannot be null");

        if (spanName == null)
            throw new IllegalArgumentException("spanName cannot be null");

        this.traceId = traceId;
        this.spanId = spanId;
        this.parentSpanId = parentSpanId;
        this.spanName = spanName;
        this.sampleable = sampleable;
        this.userId = userId;
        this.spanStartTimeEpochMicros = spanStartTimeEpochMicros;
        if (spanStartTimeNanos == null) {
            // No start time nanos was sent. Calculate it as best we can based on spanStartTimeEpochMicros, the current epoch time, and current nano time.
            long currentTimeEpochMicros = TimeUnit.MILLISECONDS.toMicros(System.currentTimeMillis());
            long currentDurationMicros = currentTimeEpochMicros - spanStartTimeEpochMicros;
            long nanoStartTimeOffset = TimeUnit.MICROSECONDS.toNanos(currentDurationMicros);
            spanStartTimeNanos = System.nanoTime() - nanoStartTimeOffset;
        }
        this.spanStartTimeNanos = spanStartTimeNanos;

        this.durationNanos = durationNanos;

        if (spanPurpose == null)
            spanPurpose = SpanPurpose.UNKNOWN;

        this.spanPurpose = spanPurpose;
        
        if(tags != null)
        		this.tags.putAll(tags);
    }

    // For deserialization only - this will create an invalid span object and is only here to support deserializers that need a default constructor but set the fields directly (e.g. Jackson)
    protected Span() {
        this("PLACEHOLDER", null, "PLACEHOLDER", "PLACEHOLDER", false, null, SpanPurpose.UNKNOWN, -1, -1L, -1L, null);
    }

    /**
     * @param spanName The {@link Span#getSpanName()} to initialize the builder with.
     * @param spanPurpose The {@link SpanPurpose} to initialize the builder with. See the javadocs for {@link SpanPurpose} for full details on what each enum option
     *                    means. If you pass in null for this then {@link SpanPurpose#UNKNOWN} will be used.
     * @return A builder setup to generate an uncompleted root span for a new trace. Since it is a root span it will have a null {@link #getParentSpanId()}.
     *          If no further changes are made to the returned builder then when {@link Builder#build()} is called the resulting span's {@link #getTraceId()}
     *          and {@link #getSpanId()} will be randomly generated, and {@link #getSpanStartTimeEpochMicros()} and {@link #getSpanStartTimeNanos()} will be set to
     *          the appropriate values based on when {@link Builder#build()} is called. If further tweaks to the span are necessary you can adjust the builder
     *          before calling {@link Builder#build()} (e.g. setting a user ID via {@link Builder#withUserId(String)}.
     */
    public static Builder generateRootSpanForNewTrace(String spanName, SpanPurpose spanPurpose) {
        return Span.newBuilder(spanName, spanPurpose);
    }

    /**
     * @param spanName The {@link Span#getSpanName()} to use for the new child sub-span.
     * @param spanPurpose The {@link SpanPurpose} for the new child span. See the javadocs for {@link SpanPurpose} for full details on what each enum option
     *                    means. If you pass in null for this then {@link SpanPurpose#UNKNOWN} will be used.
     * @return A new uncompleted span representing a child of this instance. The returned instance's {@link #getParentSpanId()} will be this instance's
     *          {@link #getSpanId()}, its {@link #getSpanName()} will be the given value, its {@link #getSpanId()} will be randomly generated, and its
     *          {@link #getSpanStartTimeEpochMicros()} and {@link #getSpanStartTimeNanos()} values will be set to the appropriate values based on when this
     *          method is called. It will share this instance's {@link #getTraceId()}, {@link #isSampleable()}, and {@link #getUserId()} values.
     */
    public Span generateChildSpan(String spanName, SpanPurpose spanPurpose) {
        return Span.newBuilder(this)
                   .withParentSpanId(this.spanId)
                   .withSpanName(spanName)
                   .withSpanId(TraceAndSpanIdGenerator.generateId())
                   .withSpanStartTimeEpochMicros(TimeUnit.MILLISECONDS.toMicros(System.currentTimeMillis()))
                   .withSpanStartTimeNanos(System.nanoTime())
                   .withDurationNanos(null)
                   .withSpanPurpose(spanPurpose)
                   .withTags(this.tags)
                   .build();
    }

    /**
     * @param spanName The {@link Span#getSpanName()} to initialize the builder with.
     * @param spanPurpose The {@link SpanPurpose} to initialize the builder with. See the javadocs for {@link SpanPurpose} for full details on what each enum
     *                    option means. If you pass in null for this then {@link SpanPurpose#UNKNOWN} will be used.
     * @return A new span builder with nothing populated beyond the given span name. Based on the behavior of {@link Builder#build()}, if you were to build it
     *          immediately you'd end up with an uncompleted root span for a new trace (same behavior as {@link #generateRootSpanForNewTrace(String, SpanPurpose)}.
     *          You are free to adjust any values before building however, so you can setup the builder to represent any span you want.
     */
    public static Builder newBuilder(String spanName, SpanPurpose spanPurpose) {
        return new Builder(spanName, spanPurpose);
    }

    /**
     * @return A new span builder that has all its fields copied from the given {@link Span}. If you call {@link Builder#build()} immediately on the returned builder you'd
     *          end up with an exact duplicate of the given span.
     */
    public static Builder newBuilder(Span copy) {
        Builder builder = new Builder(copy.spanName, copy.spanPurpose);
        builder.traceId = copy.traceId;
        builder.spanId = copy.spanId;
        builder.parentSpanId = copy.parentSpanId;
        builder.sampleable = copy.sampleable;
        builder.userId = copy.userId;
        builder.spanStartTimeEpochMicros = copy.spanStartTimeEpochMicros;
        builder.spanStartTimeNanos = copy.spanStartTimeNanos;
        builder.durationNanos = copy.durationNanos;
        builder.tags = new HashMap<String,String>(copy.tags.size());
	    builder.tags.putAll(copy.tags);
        return builder;
    }

    /**
     * @return The ID associated with the overall distributed trace - a.k.a. the trace tree ID. All spans in a distributed trace will share the same trace ID.
     *          Don't confuse this with {@link #getSpanId()}, which is the ID for an individual span of work as part of the larger distributed trace. This will never
     *          be null. NOTE: By convention this will likely be a 16 character lowercase hex-encoded 64-bit long-integer value
     *          (see {@link TraceAndSpanIdGenerator#generateId()} for details).
     */
    public String getTraceId() {
        return traceId;
    }

    /**
     * @return The ID for this span of work in the distributed trace. Don't confuse this with the {@link #getTraceId()}, which is the ID associated with the overall
     *          distributed trace and is the same for all spans in a trace. Also don't confuse this with {@link #getParentSpanId()}, which is the ID of the span that spawned
     *          this span instance (the logical "parent" of this span). This will never be null. NOTE: By convention this will likely be a 16 character
     *          lowercase hex-encoded 64-bit long-integer value (see {@link TraceAndSpanIdGenerator#generateId()} for details).
     */
    public String getSpanId() {
        return spanId;
    }

    /**
     * @return The ID of the span that spawned this span instance (the logical "parent" of this span), or null if no such parent exists. If this returns null then this
     *          span is the "root span" for the distributed trace - the ultimate ancestor of all other spans in the trace tree.
     *          NOTE: By convention this will likely be a 16 character lowercase hex-encoded 64-bit long-integer value
     *          (see {@link TraceAndSpanIdGenerator#generateId()} for details).
     */
    public String getParentSpanId() {
        return parentSpanId;
    }

    /**
     * @return The human-readable name for this span. This will never be null.
     */
    public String getSpanName() {
        return spanName;
    }

    /**
     * @return True if this span is sampleable and should be output to the logging/span collection system, false otherwise.
     */
    public boolean isSampleable() {
        return sampleable;
    }

    /**
     * @return The ID of the user logically associated with this span, or null if no such user ID exists or is appropriate.
     */
    public String getUserId() {
        return userId;
    }

    /**
     * @return The start timestamp of the span in epoch microseconds (*not* milliseconds!). NOTE: Due to java limitations this currently only has millisecond
     *          resolution (i.e. this was generated by converting {@link System#currentTimeMillis()} to microseconds), however other timestamps generated
     *          for this span will be generated relative to this starting timestamp using microsecond resolution by utilizing {@link System#nanoTime()} to
     *          calculate differences.
     */
    public long getSpanStartTimeEpochMicros() {
        return spanStartTimeEpochMicros;
    }

    /**
     * @return The start time of the span - calculated by calling {@link System#nanoTime()} when the constructor for this instance was called. WARNING: As per the
     *          javadocs for {@link System#nanoTime()} this value is *NOT* an epoch value like {@link System#currentTimeMillis()} - it is only usable when
     *          comparing against other {@link System#nanoTime()} calls performed on the *same JVM*.
     */
    public long getSpanStartTimeNanos() {
        return spanStartTimeNanos;
    }

    /**
     * @return The purpose of this span. This will never be null - if the purpose is unknown then {@link SpanPurpose#UNKNOWN} will be returned. See the javadocs
     *          for {@link SpanPurpose} for information on what each enum option means.
     */
    public SpanPurpose getSpanPurpose() {
        return spanPurpose;
    }

    /**
     * Indicates that this {@link Span} is completed/finished/finalized and sets {@link #getDurationNanos()} to be {@link System#nanoTime()} minus
     * {@link #getSpanStartTimeNanos()}. After this is called then {@link #isCompleted()} will return true and {@link #getDurationNanos()} will return
     * the value calculated here. An {@link IllegalStateException} will be thrown if this method is called after the span has already been completed.
     * <p/>
     * NOTE: This is intentionally package scoped to make sure completions and logging/span output logic happens centrally through {@link Tracer}.
     */
    void complete() {
        if (this.durationNanos != null)
            throw new IllegalStateException("This Span is already completed.");

        this.durationNanos = System.nanoTime() - spanStartTimeNanos;
        // We need to recalculate the JSON and/or key/value representation(s) of this span now that the state of the span has been modified.
        // By setting a cached value to null it will be regenerated the next time it is requested.
        cachedJsonRepresentation = null;
        cachedKeyValueRepresentation = null;
    }

    /**
     * @return true if {@link #complete()} has been called on this instance (representing a completed/finished/finalized span), false otherwise.
     */
    public boolean isCompleted() {
        return durationNanos != null;
    }

    /**
     * @return The amount of time in nanoseconds between when this span was started and when it was completed - this will return null if {@link #isCompleted()} is false.
     *          You must call {@link #complete()} to complete the span and populate the field this method returns.
     */
    public Long getDurationNanos() {
        return durationNanos;
    }

    /**
     * @return this span's *current* status relative to {@link Tracer} on the current thread at the time this method is
     * called. This status is recalculated every time this method is called and is only relevant/correct until {@link
     * Tracer}'s state is modified (i.e. by starting a subspan, completing a span, using any of the asynchronous helper
     * methods to modify the span stack in any way, etc), so it should only be considered relevant for the moment the
     * call is made.
     *
     * <p>NOTE: Most app-level developers should not need to worry about this at all.
     */
    public TracerManagedSpanStatus getCurrentTracerManagedSpanStatus() {
        return Tracer.getInstance().getCurrentManagedStatusForSpan(this);
    }
    
    /**
     * @return this spans collection of tags
     */
    public Map<String,String> getTags() {
    		return tags;
    }

    /**
     * Tags are expressed as key/value pairs. A call to this method will add the key/value pair if it exists
     * or replaces the current {@code value} if one exists for the respective {@code key}
     * 
     * @see https://github.com/opentracing/opentracing-java/blob/master/opentracing-api/src/main/java/io/opentracing/tag/Tags.java
     * @param key The tag {@code key}
     * @param value The tag {@code value} to be set
     */
    public void putTag(String key, String value) {
    		tags.put(key, value);
    }
    
    /**
     * @return The JSON representation of this span. See {@link #toJSON()}.
     */
    @Override
    public String toString() {
        return toJSON();
    }

    /**
     * @return A comma-delimited {@code key=value} string based on this {@link Span} instance.
     *         NOTE: The {@link #DURATION_NANOS_FIELD} field will be added only if {@link #isCompleted()} is true. This lets you call this method at any time
     *         and only the relevant data will be output in the returned String (e.g. in case you want to log info about the span before it has been completed).
     */
    public String toKeyValueString() {
        if (cachedKeyValueRepresentation == null)
            cachedKeyValueRepresentation = SpanParser.convertSpanToKeyValueFormat(this);

        return cachedKeyValueRepresentation;
    }

    /**
     * @return The {@link Span} represented by the given key/value string, or null if a proper span could not be deserialized from the given string.
     *          <b>WARNING:</b> This method assumes the string you're trying to deserialize originally came from
     *          {@link #toKeyValueString()}. This assumption allows it to be as fast as possible, not worry about syntactically-correct-but-annoying-to-deal-with whitespace,
     *          not have to use a third party utility, etc.
     */
    public static Span fromKeyValueString(String keyValueStr) {
    		return SpanParser.fromKeyValueString(keyValueStr);
    }
    
    /**
     * @return A JSON string based on this {@link Span} instance.
     *         NOTE: The {@link #DURATION_NANOS_FIELD} field will be added only if {@link #isCompleted()} is true. This lets you call this method at any time
     *         and only the relevant data will be output in the returned JSON (e.g. in case you want to log info about the span before it has been completed).
     */
    public String toJSON() {
        // Profiling shows this JSON creation to generate a lot of garbage in certain situations, so we should cache the result.
        if (cachedJsonRepresentation == null)
            cachedJsonRepresentation = SpanParser.convertSpanToJSON(this);

        return cachedJsonRepresentation;
    }

    /**
     * @return The {@link Span} represented by the given JSON string, or null if a proper span could not be deserialized from the given string.
     *          <b>WARNING:</b> This method assumes the JSON you're trying to deserialize originally came from {@link #toJSON()}.
     *          This assumption allows it to be as fast as possible, not have to check for malformed JSON, not worry about syntactically-correct-but-annoying-to-deal-with whitespace,
     *          not have to use a third party utility like Jackson, etc.
     */
    public static Span fromJSON(String json) {
    		return SpanParser.fromJSON(json);
    }

    /**
     * Handles the implementation of {@link Closeable#close()} for spans to allow them to be used in
     * try-with-resources statements or other libraries that work with {@link Closeable} objects.
     * <ul>
     *     <li>
     *         If this span is already completed ({@link #isCompleted()} returns true) then an error will be logged
     *         and nothing will be done.
     *     </li>
     *     <li>
     *         If this span is the current span ({@link Tracer#getCurrentSpan()} equals the given span), then {@link
     *         Tracer#completeRequestSpan()} or {@link Tracer#completeSubSpan()} will be called, whichever is
     *         appropriate.
     *     </li>
     *     <li>
     *         If this span is *not* the current span ({@link Tracer#getCurrentSpan()} does not equal this span), then
     *         this may or may not be an error depending on whether this span is managed by {@link Tracer} or not.
     *         <ul>
     *             <li>
     *                 If this span is managed by {@link Tracer} (i.e. it is contained in the span stack somewhere even
     *                 though it's not the current span) then this is a wingtips usage error - this span should not be
     *                 completed yet - and an error will be logged and this span will be completed and logged to the
     *                 "invalid span logger".
     *             </li>
     *             <li>
     *                 Otherwise this span is not managed by us, and since there may be valid use cases for manually
     *                 managing spans we must assume the call was intentional. No error will be logged, and this span
     *                 will be completed and logged to the "valid span logger".
     *             </li>
     *             <li>
     *                 In either case, {@link Tracer}'s current span stack and MDC info will be left untouched if
     *                 this span is not the current span.
     *             </li>
     *         </ul>
     *     </li>
     * </ul>
     */
    @Override
    public void close() {
        Tracer.getInstance().handleSpanCloseMethod(this);
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) {
            return true;
        }
        if (!(o instanceof Span)) {
            return false;
        }
        Span span = (Span) o;
        return sampleable == span.sampleable &&
               spanStartTimeEpochMicros == span.spanStartTimeEpochMicros &&
               spanPurpose == span.spanPurpose &&
               Objects.equals(traceId, span.traceId) &&
               Objects.equals(spanId, span.spanId) &&
               Objects.equals(parentSpanId, span.parentSpanId) &&
               Objects.equals(spanName, span.spanName) &&
               Objects.equals(userId, span.userId) &&
               Objects.equals(durationNanos, span.durationNanos) &&
               Objects.equals(tags, span.tags);
    }

    @Override
    public int hashCode() {
        return Objects.hash(traceId, spanId, parentSpanId, spanName, sampleable, userId, spanPurpose, spanStartTimeEpochMicros, durationNanos);
    }

    /**
     * Builder for creating {@link Span} objects.
     * <p/>
     * IMPORTANT NOTE: Calling {@link #build()} will choose sensible defaults for {@code traceId} and {@code spanId} if they are null when {@link #build()} is called by
     *                 calling {@link TraceAndSpanIdGenerator#generateId()} for each, and will default {@code spanStartTimeNanos} to {@link System#nanoTime()}.
     *                 This allows you to generate a fresh "root" span by creating a new instance of this builder and immediately calling {@link #build()}
     *                 without any further parameters being set. The simplest way to generate a child span is to get your hands on the parent span and call
     *                 {@link Span#generateChildSpan(String, SpanPurpose)} rather than use this builder directly. For any other use cases you can use this
     *                 builder to set any {@link Span} fields you want manually.
     */
    public static final class Builder {
        private static final Logger builderLogger = LoggerFactory.getLogger(Builder.class);

        private String traceId;
        private String spanId;
        private String parentSpanId;
        private String spanName;
        private boolean sampleable = true;
        private String userId;
        private Long spanStartTimeEpochMicros;
        private Long spanStartTimeNanos;
        private Long durationNanos;
        private SpanPurpose spanPurpose;
        private Map<String,String> tags = new HashMap<String,String>();

        private Builder(String spanName, SpanPurpose spanPurpose) {
            this.spanName = spanName;
            this.spanPurpose = spanPurpose;
        }

        /**
         * Sets the The ID associated with the overall distributed trace - a.k.a. the trace tree ID. All spans in a distributed trace will share the same trace ID.
         * Don't confuse this with {@link #withSpanId(String)}, which sets the ID for an individual span of work as part of the larger distributed trace.
         * <p/>
         * IMPORTANT NOTE: {@link Span}s are not allowed to have a null trace ID, so if this is null when {@link #build()} is called then the {@link Span} returned by
         *                 {@link #build()} will have its trace ID defaulted to a new random ID using {@link TraceAndSpanIdGenerator#generateId()}.
         *
         * @param traceId the {@code traceId} to set
         * @return a reference to this Builder
         */
        public Builder withTraceId(String traceId) {
            this.traceId = traceId;
            return this;
        }

        /**
         * Sets the ID for this span of work in the distributed trace. Don't confuse this with {@link #withTraceId(String)}, which sets the ID associated with the overall
         * distributed trace and is the same for all spans in a trace. Also don't confuse this with {@link #getParentSpanId()}, which is the ID of the span that spawned
         * this span instance (the logical "parent" of this span).
         * <p/>
         * IMPORTANT NOTE: {@link Span}s are not allowed to have a null span ID, so if this is null when {@link #build()} is called then the {@link Span} returned by
         *                 {@link #build()} will have its span ID defaulted to a new random ID using {@link TraceAndSpanIdGenerator#generateId()}.
         *
         * @param spanId the {@code spanId} to set
         * @return a reference to this Builder
         */
        public Builder withSpanId(String spanId) {
            this.spanId = spanId;
            return this;
        }

        /**
         * Sets the ID of the span that spawned this span instance (the logical "parent" of this span), or pass in null if no such parent exists. If you pass in null then
         * this instance will be a root span for the distributed trace - the ultimate ancestor of all other spans in the trace tree.
         *
         * @param parentSpanId the {@code parentSpanId} to set
         * @return a reference to this Builder
         */
        public Builder withParentSpanId(String parentSpanId) {
            this.parentSpanId = parentSpanId;
            return this;
        }

        /**
         * Sets the human-readable name for this span. This should never be null - if you set this to null and call {@link #build()} then an {@link IllegalArgumentException} will
         * be thrown.
         *
         * @param spanName the {@code spanName} to set
         * @return a reference to this Builder
         */
        public Builder withSpanName(String spanName) {
            this.spanName = spanName;
            return this;
        }

        /**
         * Set this to true if this span is sampleable and should be output to the logging/span collection system, false otherwise. This defaults to true.
         *
         * @param sampleable the {@code sampleable} value to set
         * @return a reference to this Builder
         */
        public Builder withSampleable(boolean sampleable) {
            this.sampleable = sampleable;
            return this;
        }

        /**
         * Sets the ID of the user logically associated with this span, or pass in null if no such user ID exists or is appropriate.
         *
         * @param userId the {@code userId} to set
         * @return a reference to this Builder
         */
        public Builder withUserId(String userId) {
            this.userId = userId;
            return this;
        }

        /**
         * <p>
         * Sets the start timestamp in microseconds since the epoch for this span (*not* milliseconds), or pass in null if this is a new span and
         * you want this value calculated automatically when {@link #build()} is called.
         * </p>
         * NOTE: Since Java 7 does not have a reliable way to calculate this value accurately we generally just get as close as we can by turning
         * {@link System#currentTimeMillis()} into microseconds. That means the start timestamp only has millisecond resolution.
         *
         * @param spanStartTimeEpochMicros the {@code spanStartTimeEpochMicros} to set
         * @return a reference to this Builder
         */
        public Builder withSpanStartTimeEpochMicros(Long spanStartTimeEpochMicros) {
            this.spanStartTimeEpochMicros = spanStartTimeEpochMicros;
            return this;
        }

        /**
         * <p>
         *     <b>TLDR; Passing in null (or not calling this method at all) is always a safe option - when in doubt leave this null!</b>
         * </p>
         * <p>
         *  Sets the start time of the span in nanoseconds. This value is used when calculating {@link #getDurationNanos()}. If this is left null then one of
         *  two things will be done to generate it depending on the situation:
         *  <ol>
         *      <li>
         *          If {@link #withSpanStartTimeEpochMicros(Long)} is null - this indicates a brand new span is being created on this JVM. This value will be
         *          set to {@link System#nanoTime()} when {@link #build()} is called. This leads to {@link #getDurationNanos()} being accurate to the
         *          nanosecond, however it is only possible to do this when you start and complete a given span on the same JVM.
         *      </li>
         *      <li>
         *          If {@link #withSpanStartTimeEpochMicros(Long)} is *not* null - this indicates you're deserializing a span that was created on a different
         *          JVM. This nano start time value will then be inferred based on the span's starting timestamp ({@code spanStartTimeEpochMicros}),
         *          {@link System#currentTimeMillis()}, and {@link System#nanoTime()}. You will lose a little bit of duration resolution compared with starting
         *          and completing a span on the same JVM, but it will be reasonable (guaranteed less than 1 millisecond of error).
         *      </li>
         *  </ol>
         *  This means you should only pass in a non-null value to this method when you are recreating/deserializing
         *  a span that was originally created on this exact same JVM instance. Since this is an unusual use case, you will almost always want to pass in null
         *  (or not call this method at all).
         * </p>
         *
         * @param spanStartTimeNanos the {@code spanStartTimeNanos} to set
         * @return a reference to this Builder
         */
        public Builder withSpanStartTimeNanos(Long spanStartTimeNanos) {
            this.spanStartTimeNanos = spanStartTimeNanos;
            return this;
        }

        /**
         * <p>
         *  Sets the duration of the span in nanoseconds, or null if this {@link Span} should not be considered {@link Span#isCompleted()} yet.
         * </p>
         * <p>
         *  NOTE: Under most circumstances you will want this to be null (which is the default) since there are not many use cases where you need to create an
         *  already-completed {@link Span}.
         * </p>
         *
         * @param durationNanos the {@code durationNanos} to set
         * @return a reference to this Builder
         */
        public Builder withDurationNanos(Long durationNanos) {
            this.durationNanos = durationNanos;
            return this;
        }

        /**
         * Sets the {@link SpanPurpose} for this span. See the javadocs on that class for details on what each enum option means. Passing in null is equivalent
         * to {@link SpanPurpose#UNKNOWN}.
         *
         * @param spanPurpose the {@code spanPurpose} to set
         * @return a reference to this Builder
         */
        public Builder withSpanPurpose(SpanPurpose spanPurpose) {
            this.spanPurpose = spanPurpose;
            return this;
        }
        
        /**
         * Sets the value of a tag for the respective key.  This will replace an existing tag value for the respective key.   
         * @param key the {@code key} of the tag
         * @param value the {@code value} of the tag
         * @return a reference to this Builder
         */
        public Builder withTag(String key, String value) {
        		tags.put(key, value);
        		return this;
        }
        
        /**
         * Adds all the tags from the supplied {@code Map} to the existing set of tags
         * @param tags The tags to be added to the current span
         * @return
         * @throws NullPointerException if the specified map is null, or if
         *         this map does not permit null keys or values, and the
         *         specified map contains null keys or values
         */
        public Builder withTags(Map<String,String> tags) {
        		this.tags.putAll(tags);
        		return this;
        }
        
        /**
         * <p>
         *  Returns a {@link Span} built from the parameters set via the various {@code with*(...)} methods on this builder instance.
         * </p>
         * <p>
         *  IMPORTANT NOTE: {@link Span} objects are not allowed to have null {@link Span#getTraceId()}, {@link Span#getSpanId()}, or
         *  {@link Span#getSpanStartTimeEpochMicros()}, and there are sensible defaults we can set for those values when creating a new span, so if any of them
         *  are null when this method is called it is assumed you are creating a new span and they will be set to the following:
         *  <ul>
         *      <li>{@code traceId} is defaulted to {@link TraceAndSpanIdGenerator#generateId()}</li>
         *      <li>{@code spanId} is defaulted to {@link TraceAndSpanIdGenerator#generateId()}</li>
         *      <li>{@code spanStartTimeEpochMicros} is defaulted to {@link System#currentTimeMillis()} converted to microseconds</li>
         *      <ul>
         *          <li>Side note - {@code spanStartTimeNanos} is calculated based on the rules described in {@link #withSpanStartTimeNanos(Long)}</li>
         *      </ul>
         *  </ul>
         *  Span name is also not allowed to be null, but since there is no sensible default for that value an {@link IllegalArgumentException} will be thrown
         *  if span name is null when this method is called.
         * </p>
         *
         * @return a {@code Span} built with parameters of this {@code Span.Builder}
         */
        public Span build() {
            if (traceId == null)
                traceId = TraceAndSpanIdGenerator.generateId();

            if (spanId == null)
                spanId = TraceAndSpanIdGenerator.generateId();

            if (spanStartTimeEpochMicros == null) {
                spanStartTimeEpochMicros = TimeUnit.MILLISECONDS.toMicros(System.currentTimeMillis());
                if (spanStartTimeNanos != null) {
                    // The nano start time was set but the start time in epoch microseconds was *not*.
                    //      This makes no sense, so we'll null out the nano start and log a warning.
                    builderLogger.warn("The builder was setup with a null spanStartTimeEpochMicros and non-null spanStartTimeNanos. This makes no sense "
                                       + "(if you have a nano start time then you should also have the epoch micros start time), so the nano start time "
                                       + "passed into this builder will be ignored and calculated fresh along with the epoch micros start timestamp.");
                    spanStartTimeNanos = null;
                }
            }

            if (spanStartTimeNanos == null)
                spanStartTimeNanos = System.nanoTime();

            return new Span(traceId, parentSpanId, spanId, spanName, sampleable, userId, spanPurpose, spanStartTimeEpochMicros, spanStartTimeNanos, durationNanos, tags);
        }
    }
}
