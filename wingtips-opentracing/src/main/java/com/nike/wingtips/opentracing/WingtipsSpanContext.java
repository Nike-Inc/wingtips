package com.nike.wingtips.opentracing;

import com.nike.wingtips.Span;
import com.nike.wingtips.TraceAndSpanIdGenerator;

import java.util.Map;

import io.opentracing.SpanContext;

/**
 * Extended Wingtips SpanContext.
 * It holds the span's information.
 *
 * @author <a href="mailto:ales.justin@jboss.org">Ales Justin</a>
 */
public interface WingtipsSpanContext extends SpanContext {
    /**
     * @return The ID associated with the overall distributed trace - a.k.a. the trace tree ID. All spans in a distributed trace will share the same trace ID.
     *          Don't confuse this with {@link #getSpanId()}, which is the ID for an individual span of work as part of the larger distributed trace. This will never
     *          be null. NOTE: By convention this will likely be a 16 character lowercase hex-encoded 64-bit long-integer value
     *          (see {@link TraceAndSpanIdGenerator#generateId()} for details).
     */
    String getTraceId();

    /**
     * @return The ID for this span of work in the distributed trace. Don't confuse this with the {@link #getTraceId()}, which is the ID associated with the overall
     *          distributed trace and is the same for all spans in a trace. Also don't confuse this with {@link #getParentSpanId()}, which is the ID of the span that spawned
     *          this span instance (the logical "parent" of this span). This will never be null. NOTE: By convention this will likely be a 16 character
     *          lowercase hex-encoded 64-bit long-integer value (see {@link TraceAndSpanIdGenerator#generateId()} for details).
     */
    String getSpanId();

    /**
     * @return The ID of the span that spawned this span instance (the logical "parent" of this span), or null if no such parent exists. If this returns null then this
     *          span is the "root span" for the distributed trace - the ultimate ancestor of all other spans in the trace tree.
     *          NOTE: By convention this will likely be a 16 character lowercase hex-encoded 64-bit long-integer value
     *          (see {@link TraceAndSpanIdGenerator#generateId()} for details).
     */
    String getParentSpanId();

    /**
     * @return The human-readable name for this span. This will never be null.
     */
    String getSpanName();

    /**
     * @return True if this span is sampleable and should be output to the logging/span collection system, false otherwise.
     */
    boolean isSampleable();

    /**
     * @return The ID of the user logically associated with this span, or null if no such user ID exists or is appropriate.
     */
    String getUserId();

    /**
     * @return The start timestamp of the span in epoch microseconds (*not* milliseconds!). NOTE: Due to java limitations this currently only has millisecond
     *          resolution (i.e. this was generated by converting {@link System#currentTimeMillis()} to microseconds), however other timestamps generated
     *          for this span will be generated relative to this starting timestamp using microsecond resolution by utilizing {@link System#nanoTime()} to
     *          calculate differences.
     */
    long getSpanStartTimeEpochMicros();

    /**
     * @return The start time of the span - calculated by calling {@link System#nanoTime()} when the constructor for this instance was called. WARNING: As per the
     *          javadocs for {@link System#nanoTime()} this value is *NOT* an epoch value like {@link System#currentTimeMillis()} - it is only usable when
     *          comparing against other {@link System#nanoTime()} calls performed on the *same JVM*.
     */
    long getSpanStartTimeNanos();

    /**
     * @return The purpose of this span. This will never be null - if the purpose is unknown then {@link Span.SpanPurpose#UNKNOWN} will be returned. See the javadocs
     *          for {@link Span.SpanPurpose} for information on what each enum option means.
     */
    Span.SpanPurpose getSpanPurpose();

    /**
     * Get span info as map entries.
     *
     * @return span's info as map entries
     */
    Iterable<Map.Entry<String, Object>> spanEntries();
}
